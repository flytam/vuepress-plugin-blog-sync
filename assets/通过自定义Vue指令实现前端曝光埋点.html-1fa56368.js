import{_ as p,z as o,A as c,Y as n,C as s,U as t,a6 as e,Q as l}from"./framework-cb9358d9.js";const i={},u=n("p",null,[n("img",{src:"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8e46d020d4e94c408a627d27d6ff4df0~tplv-k3u1fbpfcp-zoom-1.image",alt:""})],-1),r={href:"https://zoo.team/article/vue-command-buried-point",target:"_blank",rel:"noopener noreferrer"},k=n("p",null,[n("img",{src:"https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cd57c1709ebd4c00896ba8c3c22fb76e~tplv-k3u1fbpfcp-watermark.image",alt:"李鑫.png"})],-1),d=n("h2",{id:"前言",tabindex:"-1"},[n("a",{class:"header-anchor",href:"#前言","aria-hidden":"true"},"#"),s(" 前言")],-1),v=n("p",null,"互联网发展至今，数据的重要性已经不言而喻，尤其是在电商公司，数据的统计分析尤为重要，通过数据分析可以提升用户的购买体验，方便运营和产品调整销售策略等等。埋点就是网站分析的一种常用的数据采集方法。",-1),m=n("p",null,"埋点按照获取数据的方式一般可以分为以下 3 种：",-1),b=n("ul",null,[n("li",null,"页面埋点：统计用户进入或离开页面的各种维度信息，如页面浏览次数（PV）、浏览页面人数（UV）、页面停留时间、浏览器信息等。"),n("li",null,"点击埋点：统计用户在应用内的每一次点击事件，如新闻的浏览次数、文件下载的次数、推荐商品的命中次数等。"),n("li",null,"曝光埋点：统计具体区域是否被用户浏览到，如活动的引流入口的显示、投放广告的显示等。")],-1),g=n("strong",null,"浑仪系统",-1),h={href:"https://juejin.cn/post/6844904061934780424",target:"_blank",rel:"noopener noreferrer"},f=e(`<p>浑仪系统的数据采集是基于<strong>代码侵入式埋点方案</strong>实现的，提供了自动发送和手动调用埋点信息上报接口发送两种方式实现埋点数据上报。其中<strong>页面埋点</strong>和<strong>点击埋点</strong>是使用自动上报的方式实现，在 DOM 节点挂载特殊属性，通过<strong>埋点采集 JSSDK <strong>监听挂载了相应属性对应的事件，在事件触发时进行埋点数据上报。<strong>曝光</strong>埋点</strong>由于涉及到</strong>有效曝光逻辑的判断，自动上报不能满足相应的需求，所以我们采用手动调用接口方式进行埋点数据上报。</p><h2 id="有效曝光" tabindex="-1"><a class="header-anchor" href="#有效曝光" aria-hidden="true">#</a> 有效曝光</h2><p>先举个例子：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c66e20738ee143ba82b0c0cc14248e57~tplv-k3u1fbpfcp-zoom-1.image" alt="图片"></p><p>上图是某电商首页底部的推荐区域，为了衡量用户对推荐结果的感兴趣程度，需要计算推荐区域的点击率（点击次数/曝光次数）。为了保证点击率的准确性，我们必须确保用户真正的浏览到了这些商品，由于用户浏览商品的不确定性会发生相同商品的频繁曝光，我们还要避免重复的曝光行为。所以我们需要制定一套逻辑来规定何时进行曝光埋点的数据上报。比如：</p><ol><li>商品卡片必须完全的出现在浏览器可视化区域内。</li><li>商品必须在可视化区域内停留 5s 以上。</li><li>用户进入页面到离开页面相同的商品只进行一次曝光。</li></ol><p>满足以上规定的曝光就是一次<strong>有效曝光</strong>。了解了有效曝光后，我们来看看曝光埋点实现最重要的一环，如何判断元素出现在页面的可视化区域内。</p><h2 id="判断元素出现在页面的可视化区域内" tabindex="-1"><a class="header-anchor" href="#判断元素出现在页面的可视化区域内" aria-hidden="true">#</a> 判断元素出现在页面的可视化区域内</h2><p>我们首先想到商品曝光类似于图片懒加载的形式，通过监听 scroll 事件，调用 Element.getBoundingClientRect()方法以获取相关元素的边界信息，然后判断元素是否出现在页面的可视化区域内。由于 scroll 事件频发触发，计算量很大，所以很容易造成性能问题，虽然我们可以采用防抖节流等方式去解决。</p><p>目前有一个新的 IntersectionObserver API，提供了一种异步检测目标元素与祖先元素或 viewport（<strong>可视窗口</strong>）相交情况变化的方法。可以自动&quot;观察&quot;元素是否可见。</p><h2 id="intersectionobserver基本用法" tabindex="-1"><a class="header-anchor" href="#intersectionobserver基本用法" aria-hidden="true">#</a> IntersectionObserver基本用法</h2><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">let</span> options <span class="token operator">=</span> <span class="token punctuation">{</span>
    root<span class="token operator">:</span> document<span class="token punctuation">.</span><span class="token function">querySelector</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>#<span class="token number">39</span><span class="token punctuation">;</span>#scrollArea<span class="token operator">&amp;</span>#<span class="token number">39</span><span class="token punctuation">;</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    rootMargin<span class="token operator">:</span> <span class="token operator">&amp;</span>#<span class="token number">39</span><span class="token punctuation">;</span>0px<span class="token operator">&amp;</span>#<span class="token number">39</span><span class="token punctuation">;</span><span class="token punctuation">,</span>
    threshold<span class="token operator">:</span> <span class="token number">1.0</span>
<span class="token punctuation">}</span>
<span class="token keyword">let</span> callback <span class="token operator">=</span><span class="token punctuation">(</span>entries<span class="token punctuation">,</span> observer<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">&amp;</span>gt<span class="token punctuation">;</span> <span class="token punctuation">{</span>
  entries<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span>entry <span class="token operator">=</span><span class="token operator">&amp;</span>gt<span class="token punctuation">;</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> observer <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">IntersectionObserver</span><span class="token punctuation">(</span>callback<span class="token punctuation">,</span> options<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>IntersectionObserver 是浏览器原生提供的构造函数，接受两个参数：<code>callback </code> 是可见性变化时的回调函数，<code>option</code> 是配置对象（该参数可选），返回一个 <code>observer</code> 实例。 我们可以看到，创建一个 IntersectionObserver 对象，接受两个参数：callback 可见性变化时的回调函数，该回调函数将会在<strong>目标（target）元素和根（root）<strong>元素的交集大小超过</strong>阈值（threshold</strong>）规定的大小时候被执行。</p><p>options 是配置对象，它有以下字段：</p><ul><li>root：指定根(<strong>root</strong>)元素，用于检查目标的可见性。必须是目标元素的父级元素。如果未指定或者为 <code>null</code>，则默认为浏览器视窗。</li><li>rootMargin：根(<strong>root</strong>)元素的外边距。类似于 CSS 中的 margin 属性。默认值为 0。</li><li>threshold：target 元素和 root 元素相交程度达到该值的时候 <code>callback</code> 函数将会被执行，可以是单一的Number 也可以是 Number 数组，当为数组时每达到该值都会执行 <code>callback</code> 函数。</li></ul><p>我们通过实例的方法可以指定观察哪个 DOM 节点。实例的方法有：</p><ul><li>IntersectionObserver.observe()： 使 IntersectionObserver 开始监听一个目标元素。</li><li>IntersectionObserver.disconnect()：使 IntersectionObserver 对象停止监听工作。</li><li>IntersectionObserver.takeRecords()：返回所有观察目标的 **IntersectionObserverEntry **对象数组。</li><li>IntersectionObserver.unobserve()：使 IntersectionObserver 停止监听特定目标元素。</li></ul><p><strong>IntersectionObserverEntry</strong> 对象提供目标元素的信息，一共有七个属性：</p><ul><li>IntersectionObserverEntry.target ：需要观察的目标元素，是一个 DOM 节点对象 。</li><li>IntersectionObserverEntry.boundingClientRect：返回包含目标元素的边界信息。 边界的计算方式与 <code>Element.getBoundingClientRect()</code> 相同。</li><li>IntersectionObserverEntry.intersectionRect ：用来描述根和目标元素的相交区域的信息.</li><li>IntersectionObserverEntry.intersectionRatio：返回 <code>intersectionRect</code> 与 <code>boundingClientRect</code> 的比例值，0 为完全不可见，1 为完全可见。</li><li>IntersectionObserverEntry.isIntersecting：返回一个布尔值, 如果根与目标元素相交（即从不可视状态变为可视状态），则返回 <code>true</code>。如果返回 <code>false</code>, 变换是从可视状态到不可视状态。</li><li>IntersectionObserverEntry.rootBounds ：根元素的区域的信息。</li><li>IntersectionObserverEntry.time：可见性状态发生改变时间的时间戳，单位为毫秒。</li></ul><p>目标元素的可见性变化时，就会调用观察器的回调函数 <code>callback</code>。<code>callback </code>函数的参数 <code>entries</code> 是一个数组，每个成员都是一个 IntersectionObserverEntry 对象，<code>observer</code> 是被调用的 IntersectionObserver 实例。<code>callback</code> 函数一般会被调用两次，一次是目标元素进入可视化区域，另一次是离开可视化区域。配置 <code>options.threshold</code> 会影响 <code>callback</code> 函数的调用次数。</p><p>我们再来看看 Intersection Observer API 的浏览器兼容情况</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bcb770807027414e84f764795a706cf9~tplv-k3u1fbpfcp-zoom-1.image" alt="图片"></p>`,22),y={href:"https://github.com/w3c/IntersectionObserver/tree/master/polyfill",target:"_blank",rel:"noopener noreferrer"},_=n("code",null,"Element.getBoundingClientRect()",-1),w=e(`<h3 id="具体实现" tabindex="-1"><a class="header-anchor" href="#具体实现" aria-hidden="true">#</a> 具体实现</h3><p>了解了 Intersection Observer 的基本用法了以后，下面我们来实现前端的曝光埋点。因为业务是基于 Vue 实现的，所以我们通过自定义 Vue 指令实现前端的曝光埋点。</p><p>首先我们自定义一个 visually 指令，当指令第一次绑定在元素上时使用 IntersectionObserver 监听目标元素，当指令从元素上解绑时停止监听目标元素。</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">const</span> options <span class="token operator">=</span> <span class="token punctuation">{</span>
    root<span class="token operator">:</span> <span class="token keyword">null</span><span class="token punctuation">,</span> <span class="token comment">//默认浏览器视窗</span>
    threshold<span class="token operator">:</span> <span class="token number">1</span> <span class="token comment">//元素完全出现在浏览器视窗内才执行callback函数。</span>
<span class="token punctuation">}</span>
<span class="token keyword">const</span> callback <span class="token operator">=</span><span class="token punctuation">(</span>entries<span class="token punctuation">,</span> observer<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">&amp;</span>gt<span class="token punctuation">;</span> <span class="token punctuation">{</span>
  entries<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span>entry <span class="token operator">=</span><span class="token operator">&amp;</span>gt<span class="token punctuation">;</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> observer <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">IntersectionObserver</span><span class="token punctuation">(</span>callback<span class="token punctuation">,</span> options<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> addListenner <span class="token operator">=</span> <span class="token punctuation">(</span>ele<span class="token punctuation">,</span> binding<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">&amp;</span>gt<span class="token punctuation">;</span> <span class="token punctuation">{</span>
	observer<span class="token punctuation">.</span><span class="token function">observe</span><span class="token punctuation">(</span>ele<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> removeListener <span class="token operator">=</span> <span class="token punctuation">(</span>ele<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">&amp;</span>gt<span class="token punctuation">;</span> <span class="token punctuation">{</span>
  observer<span class="token punctuation">.</span><span class="token function">unobserve</span><span class="token punctuation">(</span>ele<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token comment">//自定义曝光指令</span>
Vue<span class="token punctuation">.</span><span class="token function">directive</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>#<span class="token number">39</span><span class="token punctuation">;</span>visually<span class="token operator">&amp;</span>#<span class="token number">39</span><span class="token punctuation">;</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>
  bind<span class="token operator">:</span> addListenner<span class="token punctuation">,</span>
  unbind<span class="token operator">:</span> removeListener<span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>我们需要一个 List 将已经上报过的埋点信息记录下来，防止重复曝光。</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">let</span> visuallyList <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">//记录已经上报过的埋点信息</span>
<span class="token keyword">const</span> addListenner <span class="token operator">=</span> <span class="token punctuation">(</span>ele<span class="token punctuation">,</span> binding<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">&amp;</span>gt<span class="token punctuation">;</span> <span class="token punctuation">{</span>
	<span class="token keyword">if</span><span class="token punctuation">(</span>visuallyList<span class="token punctuation">.</span><span class="token function">indexOf</span><span class="token punctuation">(</span>binding<span class="token punctuation">.</span>value<span class="token punctuation">)</span> <span class="token operator">!==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>
	
	observer<span class="token punctuation">.</span><span class="token function">observe</span><span class="token punctuation">(</span>ele<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>我们将要上报的信息绑定在目标元素的 &#39;visually-data&#39; 属性中，当目标元素出现在视窗内时，并停留 5 秒以上时，我们上报埋点信息。</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">let</span> timer <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token comment">//增加定时器对象</span>
<span class="token keyword">const</span> callback <span class="token operator">=</span> entries <span class="token operator">=</span><span class="token operator">&amp;</span>gt<span class="token punctuation">;</span> <span class="token punctuation">{</span>
  entries<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span>entry <span class="token operator">=</span><span class="token operator">&amp;</span>gt<span class="token punctuation">;</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> visuallyData <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
    <span class="token keyword">try</span> <span class="token punctuation">{</span>
      visuallyData <span class="token operator">=</span> <span class="token constant">JSON</span><span class="token punctuation">.</span><span class="token function">parse</span><span class="token punctuation">(</span>entry<span class="token punctuation">.</span>target<span class="token punctuation">.</span><span class="token function">getAttribute</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>#<span class="token number">39</span><span class="token punctuation">;</span>visually<span class="token operator">-</span>data<span class="token operator">&amp;</span>#<span class="token number">39</span><span class="token punctuation">;</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span>e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      visuallyData <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
      console<span class="token punctuation">.</span><span class="token function">error</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>#<span class="token number">39</span><span class="token punctuation">;</span>埋点数据格式异常<span class="token operator">&amp;</span>#<span class="token number">39</span><span class="token punctuation">;</span><span class="token punctuation">,</span> e<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">//没有埋点数据取消上报</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>visuallyData<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      observer<span class="token punctuation">.</span><span class="token function">unobserve</span><span class="token punctuation">(</span>entry<span class="token punctuation">.</span>target<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token keyword">return</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    
    <span class="token keyword">if</span> <span class="token punctuation">(</span>entry<span class="token punctuation">.</span>isIntersecting<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      timer<span class="token punctuation">[</span>visuallyData<span class="token punctuation">.</span>id<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">//上报埋点信息</span>
        <span class="token function">sendUtm</span><span class="token punctuation">(</span>visuallyData<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span>res <span class="token operator">=</span><span class="token operator">&amp;</span>gt<span class="token punctuation">;</span> <span class="token punctuation">{</span>
          <span class="token keyword">if</span> <span class="token punctuation">(</span>res<span class="token punctuation">.</span>success<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token comment">//上报成功后取消监听</span>
            observer<span class="token punctuation">.</span><span class="token function">unobserve</span><span class="token punctuation">(</span>entry<span class="token punctuation">.</span>target<span class="token punctuation">)</span><span class="token punctuation">;</span>
            visuallyList<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>visuallyData<span class="token punctuation">.</span>id<span class="token punctuation">)</span><span class="token punctuation">;</span>
            timer<span class="token punctuation">[</span>visuallyData<span class="token punctuation">.</span>id<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
          <span class="token punctuation">}</span>
        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">5000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>timer<span class="token punctuation">[</span>visuallyData<span class="token punctuation">.</span>id<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token function">clearTimeout</span><span class="token punctuation">(</span>timer<span class="token punctuation">[</span>visuallyData<span class="token punctuation">.</span>id<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      timer<span class="token punctuation">[</span>visuallyData<span class="token punctuation">.</span>id<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>最后我们引入 polyfill 实现 IE 的兼容，封装一个全局指令。</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token function">require</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>#<span class="token number">39</span><span class="token punctuation">;</span>intersection<span class="token operator">-</span>observer<span class="token operator">&amp;</span>#<span class="token number">39</span><span class="token punctuation">;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">export</span> <span class="token keyword">default</span> Vue <span class="token operator">=</span><span class="token operator">&amp;</span>gt<span class="token punctuation">;</span> <span class="token punctuation">{</span>
	<span class="token operator">...</span>
  <span class="token comment">//自定义曝光指令</span>
  Vue<span class="token punctuation">.</span><span class="token function">directive</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>#<span class="token number">39</span><span class="token punctuation">;</span>visually<span class="token operator">&amp;</span>#<span class="token number">39</span><span class="token punctuation">;</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>
    bind<span class="token operator">:</span> addListenner<span class="token punctuation">,</span>
    unbind<span class="token operator">:</span> removeListener<span class="token punctuation">,</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>我们通过 Vue.use() 引入组件后，就可以在业务代码中直接通过指令实现曝光埋点。曝光数据 visuallyData 中必须要有一个唯一 ID。</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token operator">&amp;</span>lt<span class="token punctuation">;</span>div v<span class="token operator">-</span>visually<span class="token operator">=</span><span class="token operator">&amp;</span>quot<span class="token punctuation">;</span>visuallyData<span class="token punctuation">.</span>id<span class="token operator">&amp;</span>quot<span class="token punctuation">;</span> <span class="token operator">:</span>visually<span class="token operator">-</span>data<span class="token operator">=</span><span class="token operator">&amp;</span>quot<span class="token punctuation">;</span><span class="token constant">JSON</span><span class="token punctuation">.</span><span class="token function">stringify</span><span class="token punctuation">(</span>visuallyData<span class="token punctuation">)</span><span class="token operator">&amp;</span>quot<span class="token punctuation">;</span> <span class="token keyword">class</span><span class="token operator">=</span><span class="token operator">&amp;</span>quot<span class="token punctuation">;</span>browse<span class="token operator">&amp;</span>quot<span class="token punctuation">;</span><span class="token operator">&amp;</span>gt<span class="token punctuation">;</span><span class="token operator">&amp;</span>lt<span class="token punctuation">;</span><span class="token operator">/</span>div<span class="token operator">&amp;</span>gt<span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h2 id="总结" tabindex="-1"><a class="header-anchor" href="#总结" aria-hidden="true">#</a> 总结</h2><p>埋点是数据分析的基础，埋点数据统计的准确性对后续的数据分析非常重要，所以我们在统计曝光埋点的时候一定要基于适用场景优先制定曝光埋点的规则。本文只是针对前端曝光埋点的实现方案，如有问题处，请大佬们多多交流。</p><h2 id="推荐阅读" tabindex="-1"><a class="header-anchor" href="#推荐阅读" aria-hidden="true">#</a> 推荐阅读</h2>`,15),I={href:"https://juejin.cn/post/6935226614020046878",target:"_blank",rel:"noopener noreferrer"},O={href:"https://juejin.cn/post/6940414376486633503",target:"_blank",rel:"noopener noreferrer"},j=n("h2",{id:"招贤纳士",tabindex:"-1"},[n("a",{class:"header-anchor",href:"#招贤纳士","aria-hidden":"true"},"#"),s(" 招贤纳士")],-1),x=n("p",null,"政采云前端团队（ZooTeam），一个年轻富有激情和创造力的前端团队，隶属于政采云产品研发部，Base 在风景如画的杭州。团队现有 40 余个前端小伙伴，平均年龄 27 岁，近 3 成是全栈工程师，妥妥的青年风暴团。成员构成既有来自于阿里、网易的“老”兵，也有浙大、中科大、杭电等校的应届新人。团队在日常的业务对接之外，还在物料体系、工程平台、搭建平台、性能体验、云端应用、数据分析及可视化等方向进行技术探索和实战，推动并落地了一系列的内部技术产品，持续探索前端技术体系的新边界。",-1),E=n("p",null,[s("如果你想改变一直被事折腾，希望开始能折腾事；如果你想改变一直被告诫需要多些想法，却无从破局；如果你想改变你有能力去做成那个结果，却不需要你；如果你想改变你想做成的事需要一个团队去支撑，但没你带人的位置；如果你想改变既定的节奏，将会是“5 年工作时间 3 年工作经验”；如果你想改变本来悟性不错，但总是有那一层窗户纸的模糊… 如果你相信相信的力量，相信平凡人能成就非凡事，相信能遇到更好的自己。如果你希望参与到随着业务腾飞的过程，亲手推动一个有着深入的业务理解、完善的技术体系、技术创造价值、影响力外溢的前端团队的成长历程，我觉得我们该聊聊。任何时间，等着你写点什么，发给 "),n("code",null,"ZooTeam@cai-inc.com")],-1),D=n("p",null,[n("img",{src:"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/793ad6b533944fb1abccdd4c46425f5e~tplv-k3u1fbpfcp-zoom-1.image",alt:""})],-1);function V(L,q){const a=l("ExternalLinkIcon");return o(),c("div",null,[u,n("p",null,[s("> 这是第 94 篇不掺水的原创，想获取更多原创好文，请搜索公众号关注我们吧~ 本文首发于政采云前端博客："),n("a",r,[s("通过自定义Vue指令实现前端曝光埋点"),t(a)])]),k,d,v,m,b,n("p",null,[s("政采云前端团队（ZooTeam）通过"),g,s("实现数据采集及数据可视化，分析量化的能力，想了解浑仪系统或者还不了解埋点的同学可以先阅读"),n("a",h,[s("前端工程实践之数据埋点分析系统"),t(a)]),s("。")]),f,n("p",null,[s("我们看到是存在兼容性问题的，好在已经有了兼容的 "),n("a",y,[s("polyfill"),t(a)]),s("。当前浏览器不支持 Intersection Observer API 时，使用 "),_,s("去实现 Intersection Observer API。")]),w,n("p",null,[n("a",I,[s("如何用 JS 实现二叉堆"),t(a)])]),n("p",null,[n("a",O,[s("编写高质量可维护的代码：程序范式"),t(a)])]),j,x,E,D])}const S=p(i,[["render",V],["__file","通过自定义Vue指令实现前端曝光埋点.html.vue"]]);export{S as default};
