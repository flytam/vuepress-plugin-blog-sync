import{_ as o,z as p,A as r,Y as e,C as a,U as t,a6 as s,Q as c}from"./framework-cb9358d9.js";const i={},d=e("p",null,[e("img",{src:"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/20f6e079a072435a9385ac4037166e37~tplv-k3u1fbpfcp-zoom-1.image",alt:""})],-1),l={href:"https://zoo.team/article/abstraction-and-granularity-of-component",target:"_blank",rel:"noopener noreferrer"},u=s('<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bd2bb4a713d54ef7bac545ba1a585b5e~tplv-k3u1fbpfcp-watermark.image" alt=""></p><h2 id="前言" tabindex="-1"><a class="header-anchor" href="#前言" aria-hidden="true">#</a> 前言</h2><p>作为一名精致的前端猪猪女孩，也有那么点想让自己的代码同样看起来精致一点。所以在拿到新需求的 UI 设计稿时，经常会面临如下问题：如何拆解页面？如何划分组件才算是合理？好像用于组件拆分的 A 方案和 B 方案在当前业务场景下也都还算合理，那究竟要怎么选择？组件的抽象与粒度貌似是一个老生常谈的问题了～学习了很多前辈的文章，那么今天结合业务场景，也来讲下我的心得～</p><h2 id="什么是组件" tabindex="-1"><a class="header-anchor" href="#什么是组件" aria-hidden="true">#</a> 什么是组件</h2>',4),h={href:"https://react.docschina.org/docs/components-and-props.html",target:"_blank",rel:"noopener noreferrer"},m={href:"https://cn.vuejs.org/v2/guide/components.html",target:"_blank",rel:"noopener noreferrer"},f=e("code",null,"new Vue",-1),b=s(`<p>其实总的来说，无论什么语言框架，组件就是一段代码片段，它可以实现某些指定的功能或渲染特定的展示效果，我们一般可以通过 <code>import</code> 的方式将其引入到项目代码中。本文接下来将以 React 为例进行相关描述。</p><h2 id="组件的抽象" tabindex="-1"><a class="header-anchor" href="#组件的抽象" aria-hidden="true">#</a> 组件的抽象</h2><p>组件抽象的过程就是将通用性代码“提取”或是“抽取”出去的过程，那么问题来了，我们为什么要抽组件呢？</p><h3 id="为什么要抽组件" tabindex="-1"><a class="header-anchor" href="#为什么要抽组件" aria-hidden="true">#</a> 为什么要抽组件</h3><p>说到为什么要抽取组件，不知道各位读者有没有遇到过一个 js 文件中有 1k+ ～ 2k+ 行 React 代码，甚至更多行代码的情况。这种情况往往导致代码难以维护，当有新的需求涉及相关改动时，在一定程度上增加了代码的学习成本（特别是当你刚刚新接手了一份完全不熟悉的项目的时候）。</p><p>其次，某些情况下，有一部分代码在不同场景下其实是可以复用的，例如新增和编辑的弹窗，可能只有弹窗的标题和某些字段有部分差异，此时没必要把高度相似的代码复制两遍，增加代码的冗余。</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/de9b065eaaf845289c63ec437e236423~tplv-k3u1fbpfcp-zoom-1.image" alt="图片"></p><p>因此，在我们日常开发中，组件抽取是有必要的，其目的在于代码的<strong>分层</strong>和<strong>复用</strong>，降低项目的复杂度。</p><h3 id="组件抽象的基本原则" tabindex="-1"><a class="header-anchor" href="#组件抽象的基本原则" aria-hidden="true">#</a> 组件抽象的基本原则</h3><h4 id="单一性" tabindex="-1"><a class="header-anchor" href="#单一性" aria-hidden="true">#</a> 单一性</h4><p>单一性要求一个组件具有高内聚，低耦合的特征，它只负责一件事情，不要耦合一些没必要的逻辑，并且尽量不要和其他组件有过于多的双向交互和互相依赖关系。单一性并不代表着不可以引用其他组件，当前组件可能是外层的容器组件，里面包含一些子组件，这样的设计是没问题的。</p><h4 id="复用性-通用性" tabindex="-1"><a class="header-anchor" href="#复用性-通用性" aria-hidden="true">#</a> 复用性/通用性</h4><p>在设计组件的时候，一定要考虑组件的复用性或者说是通用性。这是指，当组件封装好后，可以在<strong>类似</strong>的使用场景中直接调用。这要求我们在设计组件的时候，考虑组件功能的通用性，以及考虑组件入参的合理性。</p><p>此时有两种情况：</p><p>一种是很多不同的项目间，可能存在类似的使用场景，因此会提炼出一个公共的组件，为了复用。一般我们称之为基础组件或业务组件，姑且叫它公共组件吧。</p><p>另一种是在项目内部，仅在当前场景下作为一个独立的模块可以抽取出来作为一个组件，暂时称之为项目组件。</p><p>公共组件和项目组件在设计上的侧重也有所不同，公共组件要更多的考虑通用性，通过一个组件满足不同项目中相似的使用场景，比如 AntD 基础组件库。而项目组件更多的是处理当前业务中的特殊场景，可能是页面拆解后的不同模块，也可能是不同操作的弹窗，往往这种组件不适合直接“移植”到其他项目中使用。</p><p>然鹅，对于一个组件来说，个人认为也不能一味的追求通用性使其变得难以维护。例如，当遇到下述页面的时候，要如何抽象组件呢？</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6e0f47bb463544ee9c9a8226b4939f60~tplv-k3u1fbpfcp-zoom-1.image" alt="图片"></p><p>不难发现，页面中交易方式、基础配置和合同设置这三个模块其实是具有一定共性的，全部呈现为列表形式，只是在某些列上有展示差异。前辈的做法是，考虑了所有情况，抽象成一个组件。通过 title 区分模块名称，由于仅在交易方式模块有操作列，因此通过 areaCode 区分当前页面下的不同模块等。</p><div class="language-jsx line-numbers-mode" data-ext="jsx"><pre class="language-jsx"><code><span class="token entity named-entity" title="&lt;">&amp;lt;</span>TableConfiguration
  <span class="token comment">// 基本参数</span>
  title<span class="token operator">=</span><span class="token entity named-entity" title="&quot;">&amp;quot;</span>基础配置<span class="token entity named-entity" title="&quot;">&amp;quot;</span> <span class="token comment">// 标题名称</span>
  data<span class="token operator">=</span><span class="token punctuation">{</span>baseSettingData<span class="token punctuation">}</span> <span class="token comment">// 展示数据</span>
  areaCode<span class="token operator">=</span><span class="token entity named-entity" title="&quot;">&amp;quot;</span>baseSettingConfig<span class="token entity named-entity" title="&quot;">&amp;quot;</span> <span class="token comment">// 模块 code</span>
  config<span class="token operator">=</span><span class="token punctuation">{</span>baseSettingConfig<span class="token punctuation">}</span> <span class="token comment">// 一些业务逻辑参数</span>
  <span class="token comment">// 新增参数</span>
  pageId<span class="token operator">=</span><span class="token punctuation">{</span><span class="token keyword">this</span><span class="token punctuation">.</span>pageId<span class="token punctuation">}</span> <span class="token comment">// 当前页面 Id</span>
  userIdentity<span class="token operator">=</span><span class="token punctuation">{</span>userIdentity<span class="token punctuation">}</span> <span class="token comment">// 用户身份</span>
<span class="token operator">/</span><span class="token entity named-entity" title="&gt;">&amp;gt;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在业务发展前期，这样抽取的组件的确使用起来很方便，且通用性很强。但随着业务的膨胀，同一项目中不同页面开始出现相类似的模块，于是新增 pageId 标识，用于区分不同的页面以及对应页面的特殊逻辑。又过了一段时间，新增 userIdentity 标识，用于控制不同登录用户对页面的查看或操作权限。</p>`,22),k={href:"https://juejin.cn/post/6844904201428959239",target:"_blank",rel:"noopener noreferrer"},_=s(`<h4 id="分离处理" tabindex="-1"><a class="header-anchor" href="#分离处理" aria-hidden="true">#</a> 分离处理</h4><p>师父曾教导我说抽组件最好做一下业务层和视图层的分离处理，其中视图层主要负责页面展示样式和交互，业务层主要负责处理业务逻辑，比如接口调用，数据结构调整等。这样做的好处除了职责分离，还可以有效提高组件性能（比如视图层可以用 PureComponent 处理）。</p><p>另外，例如上述的新增和编辑弹窗，当新增和编辑两个操作需要分别调用不同接口时，业务层和视图层的分离处理可以避免组件中耦合对“新增”或“编辑”的判断，它们可以共用一个视图，并在各自的业务层实现不同的业务逻辑。</p><h3 id="组件分类" tabindex="-1"><a class="header-anchor" href="#组件分类" aria-hidden="true">#</a> 组件分类</h3><h4 id="业务组件-vs-ui-组件" tabindex="-1"><a class="header-anchor" href="#业务组件-vs-ui-组件" aria-hidden="true">#</a> 业务组件 vs UI 组件</h4><p>业务组件侧重于数据和业务的逻辑处理，其中数据一般通过接口获取。目前本团队维护的业务组件库，可以使开发人员即来即用，组件内部有完善的功能和接口数据处理，将组件引入到项目后可直接实现对应功能。</p><p>UI 组件一般也可以称为基础组件，它们经常在多个地方被复用，且不耦合任何的业务功能，例如：AntD 组件库。UI 组件侧重于页面展示效果，大部分 UI 组件具有原子性，一些复杂的 UI 组件可以由基本的 UI 组件构成。一般情况下组件内部的数据来源于父组件传递过来的 props。</p><h4 id="纯组件-vs-非纯组件" tabindex="-1"><a class="header-anchor" href="#纯组件-vs-非纯组件" aria-hidden="true">#</a> 纯组件 vs 非纯组件</h4><p>有一天，我看到前辈大神这么写的代码</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token keyword">class</span> <span class="token class-name">NotFound</span> <span class="token keyword">extends</span> <span class="token class-name">PureComponent</span> <span class="token punctuation">{</span>
  <span class="token comment">// 此处省略具体代码</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,10),g={href:"https://zhuanlan.zhihu.com/p/30659051",target:"_blank",rel:"noopener noreferrer"},v=s(`<p>一般当一个组件的 props （属性）或者 state （状态）发生改变的时候，也就是父组件传递进来的 props 发生变化或者使用 <code>this.setState</code> 函数时，组件都会进行重新渲染。</p><p>而在接受到新的 props 或者 state 到组件更新之间，其实会执行生命周期中的一个方法 <code>shouldComponentUpdate</code>，当该方法返回 <code>true</code> 时才会进行重渲染，如果返回 <code>false</code> 则不会进行重渲染。</p><p>纯组件和非纯组件的区别在于，一般情况下非纯组件并未自动实现 shouldComponentUpdate 方法的功能（但可以手动调用这个钩子），而纯组件中利用 <code>shallowEqual</code> 的方法对 props 和 state 做浅比较实现了该功能。实际应用中，纯组件一般用于纯展示型组件，相对于非纯组件来说，减少了手动判断 props 或者 state 变化的繁琐操作。并且，纯组件可以通过减少 <code>render</code> 调用次数来降低性能损耗，但是使用过程中也一定要确保此类组件的渲染仅取决于 props 与 state。</p><p>非纯组件的话，其实我们日常开发中比较常用。一般情况下，在不做特殊处理时，正常 <code>extends Component</code> 出来的组件都可以认为是非纯组件。</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token keyword">class</span> <span class="token class-name">MyComponent</span> <span class="token keyword">extends</span> <span class="token class-name">Component</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>我们可以根据实际的开发场景选择继承自 <code>PureComponent</code> 还是 <code>Component</code>。值得注意的是，由于纯组件中做的是浅比较，因此带有深层嵌套的数据是对比不出来的，请慎用～</p><h2 id="组件的粒度" tabindex="-1"><a class="header-anchor" href="#组件的粒度" aria-hidden="true">#</a> 组件的粒度</h2><p>提到组件的粒度，大多数人的第一反应可能认为拆分的越细越好。但是，这样一定是最优解嘛？个人认为其实不是的。</p><p>组件拆解的过于细致可能导致某些参数从父组件开始一层层向子组件传递，容易漏传，错传，或者其中某层组件忘记判空的时候，可能会导致页面报错。虽然可以通过 React Context 去获取，不过好像还是“徒手传递”的人更多一点。但组件如果拆解的太粗略往往也会导致复用率低、难以维护等问题。</p>`,9),j={href:"https://atomicdesign.bradfrost.com/",target:"_blank",rel:"noopener noreferrer"},y=s('<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a5c2d974aa6f47ba840cbbb289d304c1~tplv-k3u1fbpfcp-zoom-1.image" alt="图片"></p><ul><li><strong>原子组件</strong></li></ul><p>如果说，原子是物质的基本组成部分，那么原子组件就可以作为构成我们所有页面的最基本组成部分。原子组件，可以为上文中提到的基础 UI 组件，例如一个 Input 或一个 Button。它们往往具有不可再拆分的特性，是其他组件的基础。</p><ul><li><strong>分子组件</strong></li></ul><p>分子组件一般由几个简单的原子组件组成，比如由一个 Label 和一个 Input 组成的姓名输入组件。这种粒度的组件初步具有一定形态和自身属性，与原子组件相比，有一定的可操作性。</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/957c9585dcf04fa38bd264e84e16d056~tplv-k3u1fbpfcp-zoom-1.image" alt="图片"></p><ul><li><strong>生物组件</strong></li></ul><p>生物组件是由原子组件及分子组件组成的相对复杂的构成物，它是一种作为一个单元发挥作用的集合体。比如由姓名输入组件和一组按钮组成的搜索组件。在这个组件中，姓名输入组件被放置在一种使用环境中，实现了简单的功能。</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6c7d4113491d4f3b91f9aa3d50433ab6~tplv-k3u1fbpfcp-zoom-1.image" alt="图片"></p><p>有些生物组件是由不同的分子组件构成，但也有可能由相同的分子组件构成，比如网站首页的商品展示组件，该组件由六宫格组成，每个格子使用同一个分子组件进行渲染和展示。</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4dd032b0754042adab4ac0e01a5e6df1~tplv-k3u1fbpfcp-zoom-1.image" alt="图片"></p><ul><li><strong>模板组件</strong></li></ul><p>模板组件是由原子、分子、生物组件按照一定布局结构组成的区块。它们专注于页面的基础内容结构，而不是页面的最终内容。模板组件是更复杂一点的生物组件，更多的赋能于功能和展示。</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2376783275374d6a93268f92a7fceac5~tplv-k3u1fbpfcp-zoom-1.image" alt="图片"></p><ul><li>页面</li></ul><p>最终，通过不同模板组件的拼装，可以生成一个完整的页面。</p><p>在实际应用中，组件设计时的粒度往往也需要依据具体的场景具体分析，但原则可以参考高内聚，低耦合的思路，使自己的组件易于维护，同时使自己的整个项目代码看起来干净利落。</p><h2 id="总结" tabindex="-1"><a class="header-anchor" href="#总结" aria-hidden="true">#</a> 总结</h2><p>其实，本人真心认为组件的抽象与抽象粒度这件事，没有一个一成不变的统一标准，也没有对与错。在基本原则不变的情况下，更多的应该去关注如何适配不同的业务场景和需求要求，求的是“适合”。有时，同样的场景，组件粒度的标准也会随业务场景变化而变化，甚至可能随场景而持续重构。不过为了代码更好的维护和分层，以及避免代码逻辑的过度叠加和膨胀，团队中可以制定一些组件抽象的规范稍稍加以约束。</p><h2 id="参考文献" tabindex="-1"><a class="header-anchor" href="#参考文献" aria-hidden="true">#</a> 参考文献</h2>',20),x={href:"https://juejin.cn/post/6844903843189243917#heading-3",target:"_blank",rel:"noopener noreferrer"},C={href:"https://zhuanlan.zhihu.com/p/30659051",target:"_blank",rel:"noopener noreferrer"},I={href:"https://juejin.cn/post/6844903480369512455",target:"_blank",rel:"noopener noreferrer"},z={href:"https://zhuanlan.zhihu.com/p/99737118",target:"_blank",rel:"noopener noreferrer"},w=e("h2",{id:"推荐阅读",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#推荐阅读","aria-hidden":"true"},"#"),a(" 推荐阅读")],-1),U={href:"https://juejin.cn/post/6887580440803311630",target:"_blank",rel:"noopener noreferrer"},R={href:"https://juejin.cn/post/6892728697082609672",target:"_blank",rel:"noopener noreferrer"},q=e("h2",{id:"招贤纳士",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#招贤纳士","aria-hidden":"true"},"#"),a(" 招贤纳士")],-1),V=e("p",null,"政采云前端团队（ZooTeam），一个年轻富有激情和创造力的前端团队，隶属于政采云产品研发部，Base 在风景如画的杭州。团队现有 40 余个前端小伙伴，平均年龄 27 岁，近 3 成是全栈工程师，妥妥的青年风暴团。成员构成既有来自于阿里、网易的“老”兵，也有浙大、中科大、杭电等校的应届新人。团队在日常的业务对接之外，还在物料体系、工程平台、搭建平台、性能体验、云端应用、数据分析及可视化等方向进行技术探索和实战，推动并落地了一系列的内部技术产品，持续探索前端技术体系的新边界。",-1),B=e("p",null,[a("如果你想改变一直被事折腾，希望开始能折腾事；如果你想改变一直被告诫需要多些想法，却无从破局；如果你想改变你有能力去做成那个结果，却不需要你；如果你想改变你想做成的事需要一个团队去支撑，但没你带人的位置；如果你想改变既定的节奏，将会是“5 年工作时间 3 年工作经验”；如果你想改变本来悟性不错，但总是有那一层窗户纸的模糊… 如果你相信相信的力量，相信平凡人能成就非凡事，相信能遇到更好的自己。如果你希望参与到随着业务腾飞的过程，亲手推动一个有着深入的业务理解、完善的技术体系、技术创造价值、影响力外溢的前端团队的成长历程，我觉得我们该聊聊。任何时间，等着你写点什么，发给 "),e("code",null,"ZooTeam@cai-inc.com")],-1),S=e("p",null,[e("img",{src:"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9731edcd18814d519e02a5d02bbac340~tplv-k3u1fbpfcp-zoom-1.image",alt:""})],-1);function N(A,E){const n=c("ExternalLinkIcon");return p(),r("div",null,[d,e("p",null,[a("> 这是第 79 篇不掺水的原创，想获取更多原创好文，请搜索公众号关注我们吧~ 本文首发于政采云前端博客："),e("a",l,[a("编写高质量可维护的代码：组件的抽象与粒度"),t(n)])]),u,e("p",null,[e("a",h,[a("React 官方文档"),t(n)]),a("上说：组件，从概念上类似于 JavaScript 函数。它接受任意的入参（即 “props”），并返回用于描述页面展示内容的 React 元素。")]),e("p",null,[e("a",m,[a("Vue 官方文档"),t(n)]),a("说：组件是可复用的 Vue 实例，且带有一个名字。我们可以在一个通过 "),f,a(" 创建的 Vue 根实例中，把这个组件作为自定义元素来使用。")]),b,e("p",null,[a("长此以往，新增的参数越来越多，组件内部开始出现大量的判断逻辑，尽管这个组件通用性很好，能应对各种页面展示逻辑，但这也使它本身变得逐渐难以维护。还有一种比较好的解决方案是通过表单中心生成一份这样的页面，可参考"),e("a",k,[a("动态化表单设计"),t(n)]),a("。")]),_,e("p",null,[a("于是去学习了下纯组件和非纯组件的区别，首先让我们了解下"),e("a",g,[a("React 中的各种组件"),t(n)]),a("一文中对 React 组件重新渲染机制的描述：")]),v,e("p",null,[a("讲到这里，让我想到了"),e("a",j,[a("原子设计"),t(n)]),a("。原子设计是 Brad Forst 于 2013 年提出的设计概念，该作者用 5 个层级来描述组件库的设计。做下类比，映射到开发人员使用和熟知的组件中，个人认为也适合描述组件粒度。")]),y,e("p",null,[e("a",x,[a("React组件设计实践总结02 - 组件的组织"),t(n)])]),e("p",null,[e("a",C,[a("React 中的各种组件"),t(n)])]),e("p",null,[e("a",I,[a("React PureComponent 使用指南"),t(n)])]),e("p",null,[e("a",z,[a("组件化设计：原子设计实践"),t(n)])]),w,e("p",null,[e("a",U,[a("如何从 0 到 1 搭建性能检测系统"),t(n)])]),e("p",null,[e("a",R,[a("结合阿里云 FC 谈谈我对 FaaS 的理解"),t(n)])]),q,V,B,S])}const P=o(i,[["render",N],["__file","编写高质量可维护的代码：组件的抽象与粒度.html.vue"]]);export{P as default};
