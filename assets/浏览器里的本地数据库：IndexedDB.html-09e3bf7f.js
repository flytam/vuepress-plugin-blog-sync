import{_ as d,z as r,A as o,Y as e,C as t,U as n,a6 as i,Q as s}from"./framework-cb9358d9.js";const l={},c=e("p",null,[e("img",{src:"https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/5/6/171e8d2b0103c1fa~tplv-t2oaga2asx-image.image",alt:""})],-1),p=e("h2",{id:"",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#","aria-hidden":"true"},"#"),t(" **")],-1),u=e("p",null,'<table><tbody><tr><td bgcolor="#FDFFE7"><font size="4">原创不易，希望能关注下我们，再顺手点个赞~~<font></font></font></td></tr></tbody></table> **',-1),b={href:"https://www.zoo.team/article/indexeddb",target:"_blank",rel:"noopener noreferrer"},x=i('<p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/11/9/16e50a251db027b0~tplv-t2oaga2asx-image.image" alt="麦田.png"></p><h3 id="indexeddb-是什么" tabindex="-1"><a class="header-anchor" href="#indexeddb-是什么" aria-hidden="true">#</a> IndexedDB 是什么</h3><p>在现代浏览器的本地存储方案中，indexedDB 是一项重要的能力组成， 它是可以在浏览器端使用的本地数据库，可以存储大量数据，提供接口来查询，还可以建立索引，这些都是其他存储方案 Cookie 或者 LocalStorage 无法提供的能力。单从数据库类型来看，IndexedDB 是一个非关系型数据库（不支持通过 SQL 语句操作）。</p><h3 id="indexeddb-的主要概念" tabindex="-1"><a class="header-anchor" href="#indexeddb-的主要概念" aria-hidden="true">#</a> IndexedDB 的主要概念</h3><p>IndexedDB 是一个比较复杂的 API 组合，学习它的过程就相当于学习它的各个对象 API 接口，包括以下这些( IDB 指当前操作的数据库实例 )：</p><ul><li>数据库：IDBDatabase 对象</li><li>仓库对象： IDBObjectStore 对象</li><li>索引：IDBIndex 对象</li><li>事务：IDBTransaction 对象</li><li>操作请求：IDBRequest 对象</li><li>指针：IDBCursor 对象</li><li>主键：IDBKeyRange 对象</li></ul><p>在这些 API 中包含一些主要概念:</p><ul><li><p>数据库：数据库是所有相关数据的基本容器。在同源策略（ 协议 + 域名 + 端口 ）的前提下，每个域名下可以新建任意多的数据库。IndexedDB 中有版本概念，这就规定了同一时刻下只有一个版本的数据库存在。</p></li><li><p>对象仓库：对象仓库 ObjectStore 在 IndexedDB 中对应的是 MYSQL 中的表 Table。</p></li><li><p>数据：对象仓库中记录的是若干条数据，数据只有主键和数据体两个部分，主键不能重复，可以为自增的整数编号或者数据中指定的一个属性。数据体可以是任意数据类型，不限于对象。</p></li><li><p>索引：为不同的属性建立索引可以加快数据的检索。</p></li><li><p>事务：数据的 CURD (增删查改) 都要通过事务来完成。</p></li></ul><p>通过简单的对比图来理解 IndexedDB 的概念：</p><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/10/13/16dc4110e055d7b9~tplv-t2oaga2asx-image.image" alt="对比图"></p><h3 id="快速起步-indexeddb" tabindex="-1"><a class="header-anchor" href="#快速起步-indexeddb" aria-hidden="true">#</a> 快速起步 IndexedDB</h3><p>在介绍了 IndexedDB 的主要概念之后，可以通过一个简单实用的 CURD 例子来学习在日常开发中我们是怎么使用 IndexedDB 的，各个 API 细节日后可以慢慢深入学习。</p><ol><li><p>必不可少的浏览器支持检查:</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>if(&amp;#39;indexedDB&amp;#39; in window){\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div></li></ol><p>console.log(&#39;当前浏览器支持 IndexedDB&#39;); return; } else { console.log(&#39;您的浏览器不支持 IndexedDB&#39;) // todo 建议升级或者更换其他浏览器 } ```</p><ol start="2"><li><p>连接数据库</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>// 数据库实例\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div></li></ol><p>let dbInstance; // 数据库打开操作，第一个参数是数据库名称, 第二个参数是数据库版本 let DBRequestLink = window.indexedDB.open(&#39;dataBaseName&#39;, 4) DBRequestLink.onsuccess = function(event) { // 获取数据库实例 dbInstance = DBRequestLink.result; // 其他操作 }; // 这个监听回调触发于数据库首次新建、open数据库时传递新版本(只能比之前传递的版本高) DBRequestLink.onupgradeneeded = function(event) {}; ```</p><ol start="3"><li><p>创建数据库的主键和字段</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>DBOpenRequest.onupgradeneeded = function(event) {\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div></li></ol><p>let db = event.target.result;</p><p>// 创建一个数据库存储对象，并指定主键 let objectStore = db.createObjectStore(&#39;person&#39;, { keyPath: &#39;id&#39;, autoIncrement: true });</p><p>/* 定义存储对象的数据项 * 第一个参数是创建的索引名称，可以为空 * 第二个参数是索引使用的关键名称，可以为空 * 第三个参数是可选配置参数，可以不传，常用参数之一就是 unique ，表示该字段是否唯一，不能重复 */ objectStore.createIndex(&#39;id&#39;, &#39;id&#39;, { unique: true<br> }); objectStore.createIndex(&#39;name&#39;, &#39;name&#39;); objectStore.createIndex(&#39;age&#39;, &#39;age&#39;); objectStore.createIndex(&#39;sex&#39;, &#39;sex&#39;); }; ```</p><pre><code>在上述操作中，我们先定义了上文中提到的 IDBObjectStore 对象，并指定主键为 id ，随后又通过 createIndex 来创建字段。值得注意的是虽然创建了四个字段，但在 IndexedDb 中数据还是分为主键 id 和数据主体两个部分，并不会像 MYSQL 中在 Table 中呈现四列。\n</code></pre><ol start="4"><li><p>向数据库中添加数据</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>// 这里的 dbInstance 就是第二步中的 dbInstance 对象， \n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div></li></ol><p>// transaction api 的第一个参数是数据库名称，第二个参数是操作类型 let newItem = { id: 1, name: &#39;徐嘻嘻&#39;, age: 3, sex: &#39;female&#39; }; let transaction = dbInstance.transaction(&#39;person&#39;, &quot;readwrite&quot;); // 找到对应的存储对象 let objectStore = transaction.objectStore(&#39;person&#39;); // 添加到数据对象中, 传入javascript对象 objectStore.add(newItem); ```</p><pre><code>新建操作是在新建了一个 事务（ IDBTransaction 对象）的前提下完成的，传入的数据不需要做任何转换，可以无缝传入 Javascript 对象。\n</code></pre><ol start="5"><li><p>修改数据库中的数据</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>// 这里的 dbInstance 就是第二步中的 dbInstance 对象， \n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div></li></ol><p>// 新建事务 let transaction = dbInstance.transaction(&#39;person&#39;, &quot;readwrite&quot;); // 新数据主体 let newRecord = { id: 1, name: &#39;徐嘎嘎&#39;, age: 5, sex: &#39;male&#39; }; // 打开已经存储的数据对象 let objectStore = transaction.objectStore(&#39;person&#39;); // 获取存储的对应键的存储对象, 传入主键 id，值为 1<br> let objectStoreRequest = objectStore.get(1); // 获取成功后替换当前数据 objectStoreRequest.onsuccess = function(event) { // 数据 var record = objectStoreRequest.result; // 遍历替换 for (let key in newRecord) { if (typeof record[key] != &#39;undefined&#39; || key !== &#39;id&#39;) { record[key] = newRecord[key]; } } // 更新数据库存储数据<br> objectStore.put(record); }; ```</p><pre><code>基本思路是创建一个事务，先找到想要修改的数据主体，然后在更新该数据主体内容。 事务创建逻辑相同，并在创建之后调用事务的 get 和 put 操作。\n</code></pre><ol start="6"><li><p>删除数据库中的数据</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>// 这里的 dbInstance 就是第二步中的 dbInstance 对象， \n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div></li></ol><p>// 新建事务 let transaction = dbInstance.transaction(&#39;person&#39;, &quot;readwrite&quot;); // 打开已经存储的数据对象 let objectStore = transaction.objectStore(&#39;person&#39;); // 获取存储的对应键的存储对象, 传入主键 id，值为 1<br> let objectStoreRequest = objectStore.delete(1); ```</p><pre><code>调用 delete 接口，传入指定的 id 即可。\n</code></pre><h3 id="可以提效的类库" tabindex="-1"><a class="header-anchor" href="#可以提效的类库" aria-hidden="true">#</a> 可以提效的类库</h3><p>​ 从上面的例子中可以看出，每一次操作需要至少三行代码才能完成，而且需要一直维护 DB 的对象引用，避免它被回收，这样子开发代码膨胀得太厉害，所以我们在业务中引入其他类库来减少代码量</p><ul><li><strong>LocalForage</strong><ul><li>可以指定数据存储方案，默认依次为 IndexedDB、WebSQL、LocalStorage，意味着当前 IndexedDB 失效可以有兜底措施。</li><li>API 简化为 CRUD ( getItem、removeItem、setItem、clear )</li><li>库大小为 475b</li></ul></li><li><strong>Pouchdb</strong><ul><li>API 简化为 put、get、remove，基于 promise 来检查回收错误</li><li>有较好的错误日志机制， 如失败，冲突等等，方便调试</li><li>库大小为 255b</li></ul></li></ul><p>这两个类库比较符合我们的开发要求，我们当前使用的是 LocalForage。</p><h3 id="结束语" tabindex="-1"><a class="header-anchor" href="#结束语" aria-hidden="true">#</a> 结束语</h3><p>在业务开发中，我们都会碰到或多或少的本地存储需求，本文介绍了其中一种存储方案 IndexedDB 的简单实践。就我们的应用场景来看，IndexedDB 的适用面还是很广的。考虑到 IE10 也可以支持，把它实践在实际项目中应该是没有问题的。</p><p>文章内容较长，如果表达有误在所难免，欢迎交流指出。</p><h2 id="招贤纳士" tabindex="-1"><a class="header-anchor" href="#招贤纳士" aria-hidden="true">#</a> 招贤纳士</h2><p>招人，前端，隶属政采云前端大团队（ZooTeam），50 余个小伙伴正等你加入一起浪～ 如果你想改变一直被事折腾，希望开始能折腾事；如果你想改变一直被告诫需要多些想法，却无从破局；如果你想改变你有能力去做成那个结果，却不需要你；如果你想改变你想做成的事需要一个团队去支撑，但没你带人的位置；如果你想改变“5年工作时间3年工作经验”；如果你想改变本来悟性不错，但总是有那一层窗户纸的模糊… 如果你相信相信的力量，相信平凡人能成就非凡事，相信能遇到更好的自己。如果你希望参与到随着业务腾飞的过程，亲手参与一个有着深入的业务理解、完善的技术体系、技术创造价值、影响力外溢的前端团队的成长历程，我觉得我们该聊聊。任何时间，等着你写点什么，发给<code>ZooTeam@cai-inc.com</code></p><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/5/6/171e8b8d7ad15181~tplv-t2oaga2asx-image.image" alt=""></p><h2 id="推荐阅读" tabindex="-1"><a class="header-anchor" href="#推荐阅读" aria-hidden="true">#</a> 推荐阅读</h2>',41),g={href:"https://juejin.cn/post/6844903959224664077",target:"_blank",rel:"noopener noreferrer"},h={href:"https://juejin.cn/post/6844903950508883982",target:"_blank",rel:"noopener noreferrer"},m={href:"https://juejin.cn/post/6844903933580673032",target:"_blank",rel:"noopener noreferrer"};function I(v,_){const a=s("ExternalLinkIcon");return r(),o("div",null,[c,p,u,e("p",null,[t("> 本文首发于政采云前端团队博客： "),e("a",b,[t("浏览器里的本地数据库：IndexedDB"),n(a)])]),x,e("p",null,[e("a",g,[t("写给前端工程师的 Serverless 入门"),n(a)])]),e("p",null,[e("a",h,[t("前端工程实践之可视化搭建系统（一）"),n(a)])]),e("p",null,[e("a",m,[t("自动化 Web 性能优化分析方案"),n(a)])])])}const B=d(l,[["render",I],["__file","浏览器里的本地数据库：IndexedDB.html.vue"]]);export{B as default};
