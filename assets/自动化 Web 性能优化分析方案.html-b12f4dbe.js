import{_ as s,z as o,A as r,Y as e,C as a,U as i,a6 as n,Q as d}from"./framework-cb9358d9.js";const l={},p=e("h2",{id:"",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#","aria-hidden":"true"},"#"),a(" **")],-1),h=e("p",null,'<table><tbody><tr><td bgcolor="#FDFFE7"><font size="4">原创不易，希望能关注下我们，再顺手点个赞~~<font></font></font></td></tr></tbody></table> **',-1),c={href:"https://www.zoo.team/article/performance-detection",target:"_blank",rel:"noopener noreferrer"},g=n(`<p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/11/9/16e5090535071e8a~tplv-t2oaga2asx-image.image" alt="牧羊.png"></p><p>在构建 Web 站点的过程中，任何一个细节都有可能影响网站的访问速度。如果开发人员不了解前端性能相关知识，很多不利网站访问速度的因素会在线上形成累加，从而严重影响网站的性能，导致网站访问速度变慢、用户体验低下，最终导致用户流失。页面性能对网页而言，可谓举足轻重。因此，对页面的性能进行检测分析，是开发者不可忽视的课题。那么我们如何对页面进行监控分析及性能评判？对性能评判的规则又是什么样的呢？</p><p>从技术方面来讲，前端性能监控主要分为两种方式，一种叫做合成监控（Synthetic Monitoring，SYN），另一种是真实用户监控（Real User Monitoring，RUM）。</p><ul><li><p>合成监控，就是在一个模拟场景里，去提交一个需要做性能检测的页面，通过一系列的工具、规则去运行你的页面，提取一些性能指标，得出一个性能报告。</p></li><li><p>真实用户监控，就是用户在我们的页面上访问，访问之后就会产生各种各样的性能数据，我们在用户离开页面的时候，把这些性能数据上传到我们的日志服务器上，进行数据的提取清洗加工，最后在我们的监控平台上进行展示的一个过程。</p></li></ul><p>前者注重 ”检测“，后者注重”监控“。</p><p>下文将从多个方面，向大家介绍政采云前端 ZooTeam 的 Web 性能优化分析系统—— “百策”，是如何采集页面性能数据，并通过一系列计算加工，产出页面性能报表的。</p><p>&gt; 百策，取名自历史人物魏征。魏征，字玄成。唐太宗李世民的谏臣，因敢于直谏，被称为诤臣。因多次指出台唐太宗李世民的过错并能提出有效政策，因为被称为 “魏百策”。</p><h2 id="如何采集页面性能数据" tabindex="-1"><a class="header-anchor" href="#如何采集页面性能数据" aria-hidden="true">#</a> 如何采集页面性能数据</h2><p>百策系统采用了上文提到的 “合成监控” 的方案，得到了一组与宿主环境无关的性能数据。说到合成监控方案，当属 Google Chrome 团队出品的开源自动化分析工具 Lighthouse。</p><p>Lighthouse 的工作流程有几个主要的步骤。部分步骤发生在浏览器中，其余的步骤由 Lighthouse 运行器执行。</p><h3 id="lighthouse-工作原理" tabindex="-1"><a class="header-anchor" href="#lighthouse-工作原理" aria-hidden="true">#</a> Lighthouse 工作原理</h3><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/11/9/16e50acfe49347c6~tplv-t2oaga2asx-image.image" alt="img"></p><p>下面是 Lighthouse 的组成部分：</p><ul><li><strong>驱动</strong> 和 Chrome Debugging Protocol 进行交互。</li><li><strong>收集器</strong>  使用驱动程序收集网页信息。最小化后处理。收集器的输出结果被称为 <strong>Artifact</strong>。</li><li><strong>审查器</strong> 将 <strong>Artifact</strong> 作为输入，审查器会对其运行 1 个测试，然后分配通过/失败/得分的结果。</li><li><strong>类别</strong>   将审查的结果分组到面向用户的报告中（如最佳实践）。对该部分加权求和然后得出评分。</li></ul><p>简单来说流程就是：建立连接 -&gt; 收集日志 -&gt; 分析 -&gt; 生成报告。</p><p>而我们的百策系统是在 Lighthouse 的基础上，进行了部分功能的定制和创新。</p><h3 id="区别于-lighthouse-的功能" tabindex="-1"><a class="header-anchor" href="#区别于-lighthouse-的功能" aria-hidden="true">#</a> 区别于 Lighthouse 的功能</h3><h4 id="_1-使用-puppeteer" tabindex="-1"><a class="header-anchor" href="#_1-使用-puppeteer" aria-hidden="true">#</a> 1）使用 Puppeteer</h4><p>Puppeteer 是一个 Node 库，它提供了一个高级 API 来通过 <a href="%3Chttps://zhaoqize.github.io/puppeteer-api-zh_CN/(https://chromedevtools.github.io/devtools-protocol/)%3E">DevTools</a> 协议控制 Chromium 或 Chrome。相比较 <code>Selenium</code> 或是 <code>PhantomJs</code> ，它最大的特点就是它的 <code>DOM</code> 操作可以完全在内存中进行模拟，即在 <code>V8</code> 引擎中处理而不打开浏览器，而且 <code>V8</code> 引擎 Chrome 团队在维护，会拥有更好的兼容性和前景。</p><p>运行下面这段代码就能获取到视窗可视区域的宽高：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>const puppeteer = require(&amp;#39;puppeteer&amp;#39;);

(async () =&amp;gt; {
  const browser = await puppeteer.launch();
  const page = await browser.newPage();
  await page.goto(&amp;#39;https://example.com&amp;#39;);

  const dimensions = await page.evaluate(() =&amp;gt; {
    return {
      width: document.documentElement.clientWidth,
      height: document.documentElement.clientHeight
    };
  });

  console.log(&amp;#39;Dimensions:&amp;#39;, dimensions);

  await browser.close();
})();
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>Lighthouse 的方案是使用更底层的 DevTools 协议和浏览器交互，我们选择 Puppeteer 是因为其更简单，封装的一些常用的接口足够满足我们的需求。</p><h4 id="_2-访问页面前模拟登录" tabindex="-1"><a class="header-anchor" href="#_2-访问页面前模拟登录" aria-hidden="true">#</a> 2）访问页面前模拟登录</h4><p>我们不仅需要检测可匿名访问的前台页面，也需要检测登录后才能操作的后台页面。所以在检测前，我们需要增加一步登录操作。当然这个用户名密码也是可选的，当检测到这个 URL 需要登录时，才会提醒用户输入用户名密码。</p><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/11/9/16e50acfe5962f37~tplv-t2oaga2asx-image.image" alt="image-20190828125412091"></p><h4 id="_3-收集到数据存入数据库" tabindex="-1"><a class="header-anchor" href="#_3-收集到数据存入数据库" aria-hidden="true">#</a> 3）收集到数据存入数据库</h4><p>我们将每一次的检测数据保存入库，对数据进行整理，获取页面性能变化所呈现的趋势，为支持后续的统计分析提供数据保证。</p><p>&gt; 改造之后的流程是：建立连接 -&gt; <strong>登录检测</strong> -&gt; 收集日志 -&gt; <strong>数据入库</strong> -&gt; 分析 -&gt; 生成报告</p><h2 id="如何分析页面性能" tabindex="-1"><a class="header-anchor" href="#如何分析页面性能" aria-hidden="true">#</a> 如何分析页面性能</h2><h3 id="定制各项指标" tabindex="-1"><a class="header-anchor" href="#定制各项指标" aria-hidden="true">#</a> 定制各项指标</h3><p>系统设计初期，我们拟定了一系列性能指标的权重和阈值：</p><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/11/9/16e50acfe5ae53b5~tplv-t2oaga2asx-image.image" alt="image-20190828144107224"></p><p>Lighthouse 也制定了很多性能指标，譬如：</p><ul><li>uses-webp-images：采用新一代格式提供图片</li><li>dom-size：DOM 节点总数</li><li>network-requests：页面加载完成时的请求数</li><li>…...</li></ul><p>除此之外我们定制了更多的特色指标，譬如：OSS 图片是否使用了压缩后缀。</p><p>由于公司的图片都是放在阿里云 OSS 上的，阿里云 OSS提供了很方便的优化图片体积的方法，就是给图片的末尾加上类似参数 <code>?x-oss-process=image/resize,w_187/quality,Q_75/format,webp</code>，理论上放在 OSS 上的图片都需要添加压缩后缀。为什么说是理论上呢？因为我们发现如果图片上传 OSS 前，事先经过了其他压缩工具的压缩，再添加压缩后缀后，图片的体积变化不大，甚至会出现负增长。所以我们调整了评审算法，不再是简单地检查图片是否增加了 OSS 后缀，而是比较当前图片的体积与添加 OSS 压缩后缀后体积的差值是否超出比例。</p><h3 id="定制检测模型" tabindex="-1"><a class="header-anchor" href="#定制检测模型" aria-hidden="true">#</a> 定制检测模型</h3><p>检测系统试运行一段时间后，我们发现并不是所有的指标都适用于所有类型的页面。譬如我们的前台页面加载图片很多且对图片分辨率要求较高、而后台页面图片则比较少。我们既有传统的后端渲染 + jQuery 类型的页面、客户端渲染 React 页面、也有经过预渲染的 Vue 页面。</p><p>将所有类型的页面按同一标准进行检测显然不太合适，所以我们引入了 <strong>检测模型</strong> 的概念。我们根据页面所属的类型，按照对应检测模型进行性能检测。一个检测模型可以关联多个指标，并可以配置指标权重和级别。</p><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/11/9/16e50acfe5c22290~tplv-t2oaga2asx-image.image" alt="image-20190828150056418"></p><p>权重越大扣分越多，级别分为 error 和 warning，其中 warning 级别的扣分项不算入总分中，譬如请求是否使用 Gzip 就是，因为这一项是前端无法优化的，需要推动服务端去改进。</p><h3 id="计算页面评分" tabindex="-1"><a class="header-anchor" href="#计算页面评分" aria-hidden="true">#</a> 计算页面评分</h3><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/11/9/16e50acfe5fb510f~tplv-t2oaga2asx-image.image" alt="image-20190828145940506"></p><h2 id="提供优化建议和趋势" tabindex="-1"><a class="header-anchor" href="#提供优化建议和趋势" aria-hidden="true">#</a> 提供优化建议和趋势</h2><h3 id="优化建议" tabindex="-1"><a class="header-anchor" href="#优化建议" aria-hidden="true">#</a> 优化建议</h3><p>针对每项扣分的审查项，我们都提供了详细的扣分原因，以及对应的解决方案：</p><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/11/9/16e50acfe6d2eda0~tplv-t2oaga2asx-image.image" alt="image-20190828151816414"></p><h3 id="页面性能趋势变化图" tabindex="-1"><a class="header-anchor" href="#页面性能趋势变化图" aria-hidden="true">#</a> 页面性能趋势变化图</h3><p>除了开发新的功能，我们还积极地对老页面进行重构，为了分析重构前后的收益，我们还提供了查询历史数据和变化趋势的功能：</p><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/11/9/16e50ad047ee64e6~tplv-t2oaga2asx-image.image" alt=""></p><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/11/9/16e50ad01ee8df88~tplv-t2oaga2asx-image.image" alt="image-20190828152356104"></p><h2 id="总结" tabindex="-1"><a class="header-anchor" href="#总结" aria-hidden="true">#</a> 总结</h2><p>百策系统为前端页面提供性能优化分析服务，结合行业方案及业务场景的差异性，完善符合公司业务情况的最佳实践，百策系统制定了一套 Web 页面性能的检测标准，通过页面检测及模型分析，发现页面中请求耗时过长、请求资源过大、页面结构不合理等影响用户体验的问题，并针对问题提供相应的优化建议，帮助开发者产出渲染速度更快、资源占有更少、体验更好的页面。</p><p>后续，我们还会对 “百策系统” 进行系列分享，欢迎大家先关注微信公众号 “政采云前端团队”，或者掘金上关注 “政采云前端团队”，以便第一时间获取最新信息。分享预告：</p><ul><li>《爬虫实战：模拟用户登录抓取页面性能数据》</li><li>《初识 NestJS：不用写 SQL 我也能开发后台》</li><li>《文档站点：不用 Gitlab CI 搭建持续集成的文档站点》</li><li>《图片体积优化：四舍五入我为公司节省一个亿》</li><li>《Node 性能优化：我是如何懵逼应对 Node 定时批量任务爆栈的》</li></ul><h2 id="招贤纳士" tabindex="-1"><a class="header-anchor" href="#招贤纳士" aria-hidden="true">#</a> 招贤纳士</h2><p>招人，前端，隶属政采云前端大团队（ZooTeam），50 余个小伙伴正等你加入一起浪～ 如果你想改变一直被事折腾，希望开始能折腾事；如果你想改变一直被告诫需要多些想法，却无从破局；如果你想改变你有能力去做成那个结果，却不需要你；如果你想改变你想做成的事需要一个团队去支撑，但没你带人的位置；如果你想改变“5年工作时间3年工作经验”；如果你想改变本来悟性不错，但总是有那一层窗户纸的模糊… 如果你相信相信的力量，相信平凡人能成就非凡事，相信能遇到更好的自己。如果你希望参与到随着业务腾飞的过程，亲手参与一个有着深入的业务理解、完善的技术体系、技术创造价值、影响力外溢的前端团队的成长历程，我觉得我们该聊聊。任何时间，等着你写点什么，发给<code>ZooTeam@cai-inc.com</code></p><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/8/29/16cddbe09f60b388~tplv-t2oaga2asx-image.image" alt=""></p><h2 id="推荐阅读" tabindex="-1"><a class="header-anchor" href="#推荐阅读" aria-hidden="true">#</a> 推荐阅读</h2>`,59),m={href:"https://juejin.cn/post/6844903950508883982",target:"_blank",rel:"noopener noreferrer"},u={href:"https://juejin.cn/post/6844903938018263048",target:"_blank",rel:"noopener noreferrer"},b={href:"https://juejin.cn/post/6844903933580673032",target:"_blank",rel:"noopener noreferrer"};function v(_,f){const t=d("ExternalLinkIcon");return o(),r("div",null,[p,h,e("p",null,[a("> 本文首发于政采云前端团队博客： "),e("a",c,[a("自动化 Web 性能优化分析方案"),i(t)])]),g,e("p",null,[e("a",m,[a("前端工程实践之可视化搭建系统（一）"),i(t)])]),e("p",null,[e("a",u,[a("看完这篇，你也能把 React Hooks 玩出花"),i(t)])]),e("p",null,[e("a",b,[a("自动化 Web 性能优化分析方案"),i(t)])])])}const j=s(l,[["render",v],["__file","自动化 Web 性能优化分析方案.html.vue"]]);export{j as default};
