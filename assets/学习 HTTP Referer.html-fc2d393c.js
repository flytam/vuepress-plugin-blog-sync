import{_ as n,z as l,A as o,Y as e,C as r,U as a,a6 as i,Q as d}from"./framework-cb9358d9.js";const s={},c=e("p",null,[e("img",{src:"https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bfefad3ee3474e3a8a461251aaddceb4~tplv-k3u1fbpfcp-watermark.image?",alt:"政采云技术团队.png"})],-1),p=e("p",null,[e("img",{src:"https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8583065dd4a64c1ca84f3dac99506518~tplv-k3u1fbpfcp-watermark.image?",alt:"维尼.png"})],-1),h={href:"https://www.zoo.team/article/http-referer",target:"_blank",rel:"noopener noreferrer"},f=i(`<h1 id="背景" tabindex="-1"><a class="header-anchor" href="#背景" aria-hidden="true">#</a> 背景</h1><p>HTTP 中 Referer 字段在工作中或许并不会吸引你的注意，隐藏在 Network 的请求之下，但是却有着非常重要的作用。平常你一定会遇到一些问题需要去排查，假如这个问题在你排查完全部代码后，依然没有解决，这个时候你会怎么办？此时我们就需要将排查问题的角度转换一下，切换到 HTTP 协议上。</p><p>最近工作当中也碰到了与此相关的一些问题，借此机会也同时做个记录和总结。HTTP 协议整体包含内容非常多，本次我们只把其中的 Referer 字段拿出来和大家详细说一下。</p><h1 id="http-referer" tabindex="-1"><a class="header-anchor" href="#http-referer" aria-hidden="true">#</a> HTTP Referer</h1><h2 id="referer-是什么" tabindex="-1"><a class="header-anchor" href="#referer-是什么" aria-hidden="true">#</a> Referer 是什么？</h2><p>HTTP Referer 是 HTTP 表头的一个字段，用来表示当前网页是来源于哪里，采用的格式是 URL。我们通过这个 HTTP Referer，可以查到访客的来源。</p><p>可以通过 Network 面板看到，页面访问及资源请求的 Request Headers 请求头信息里有一个 Referer 字段，用来标记来源的 URL。</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/af20b28299904394973399bfbbf341a8~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p><p>有同学可能会注意到 Referer “似乎”拼写有误，应该是 “Referrer&quot; 才对，这其实是个历史原因，在早期 HTTP 规范当中就存在的拼写错误，后面为了向下兼容，所以将错就错。</p><p>拼写错误只有 Request Headers 的 “Referer”，在其他地方比如General Headers、 JavaScript 及 DOM 上，都是正确的拼写。</p><p>General Headers：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7f7bfd870e624641a4ac6eda7b04b4be~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p><div class="language-javaScript line-numbers-mode" data-ext="javaScript"><pre class="language-javaScript"><code>// javascript
document.referrer

// DOM
&amp;lt;a target=&amp;quot;_blank&amp;quot; href=&amp;quot;https://edu.zcygov.cn/live&amp;quot; referrerpolicy=&amp;quot;no-referrer&amp;quot;&amp;gt;查看链接&amp;lt;/a&amp;gt;
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>到此大家应该对 Referer 有了一个大概的了解，那么 Referer 字段在什么条件下会展示，以及如何去控制 Referer 返回的具体内容呢？答案就在 Referrer-Policy 当中，下面就带大家详细讲一下 Referrer-Policy 策略。</p><h2 id="referrer-policy-策略" tabindex="-1"><a class="header-anchor" href="#referrer-policy-策略" aria-hidden="true">#</a> Referrer-Policy 策略</h2><h3 id="有哪些策略" tabindex="-1"><a class="header-anchor" href="#有哪些策略" aria-hidden="true">#</a> 有哪些策略？</h3><h4 id="referrer-policy-no-referrer" tabindex="-1"><a class="header-anchor" href="#referrer-policy-no-referrer" aria-hidden="true">#</a> <strong>Referrer-Policy: no-referrer</strong></h4><p>顾名思义，这个策略表示不发送 Referer 信息。</p><p>工作中实际使用的场景：</p><p>在双品牌“乐彩云”推广中为降低双域名跳转改造成本，运维层面在Nginx添加了一个规则，若访问链接（例如 news.zcygov.cn）的 Referer 包含 lecaiyun.com 域名，则会强制将访问链接的域名变更为 lecaiyun.com ，实现链接跳转统一。</p><p>若部分域名不需要走这一套逻辑，不携带 Referer 头信息，则需要指定 Referrer-Policy 策略为 no-referrer 。</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/903db37bc96443b8992aa7c16c21a907~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p><h4 id="referrer-policy-no-referrer-when-downgrade" tabindex="-1"><a class="header-anchor" href="#referrer-policy-no-referrer-when-downgrade" aria-hidden="true">#</a> Referrer-Policy: no-referrer-when-downgrade</h4><p>如果从 HTTPS 网址链接到 HTTP 网址，不发送Referer字段，其他情况发送（包括 HTTP 网址链接到 HTTP 网址）。</p><p>此规则原先是大多数浏览器的默认策略，现在随着隐私安全性的要求变高之后，浏览器将默认规则变更成了 strict-origin-when-cross-origin。</p><h4 id="referrer-policy-origin" tabindex="-1"><a class="header-anchor" href="#referrer-policy-origin" aria-hidden="true">#</a> Referrer-Policy: origin</h4><p>Referer字段一律只发送源信息（协议+域名+端口），不管是否跨域。</p><h4 id="referrer-policy-origin-when-cross-origin" tabindex="-1"><a class="header-anchor" href="#referrer-policy-origin-when-cross-origin" aria-hidden="true">#</a> Referrer-Policy: origin-when-cross-origin</h4><p>同源时，发送完整的Referer字段，跨域时发送源信息。</p><h4 id="referrer-policy-same-origin" tabindex="-1"><a class="header-anchor" href="#referrer-policy-same-origin" aria-hidden="true">#</a> Referrer-Policy: same-origin</h4><p>链接到同源网址（协议+域名+端口 都相同）时发送，否则不发送。注意，https://foo.com 链接到 http://foo.com 也属于跨域，因为两者的协议不同。</p><h4 id="referrer-policy-strict-origin" tabindex="-1"><a class="header-anchor" href="#referrer-policy-strict-origin" aria-hidden="true">#</a> Referrer-Policy: strict-origin</h4><p>如果从 HTTPS 网址链接到 HTTP 网址，不发送Referer字段，其他情况只发送源信息。</p><h4 id="referrer-policy-strict-origin-when-cross-origin" tabindex="-1"><a class="header-anchor" href="#referrer-policy-strict-origin-when-cross-origin" aria-hidden="true">#</a> Referrer-Policy: strict-origin-when-cross-origin</h4><p>同源时，发送完整的Referer字段；跨域时，如果 HTTPS 网址链接到 HTTP 网址，不发送Referer字段，否则发送源信息。</p><h4 id="referrer-policy-unsafe-url" tabindex="-1"><a class="header-anchor" href="#referrer-policy-unsafe-url" aria-hidden="true">#</a> Referrer-Policy: unsafe-url</h4><p>Referer字段包含源信息、路径和查询字符串，不包含锚点、用户名和密码。</p><p>针对以上策略，可以根据策略及 Referer 携带信息的完整度，可以总结成一个表格，可以按照自己的需求配置不同的策略：</p><table><thead><tr><th style="text-align:left;"></th><th style="text-align:left;">不携带任何 Referer 信息</th><th style="text-align:left;">Referer 只携带域名 Origin 信息</th><th style="text-align:left;">Referer 携带完整 URL 信息</th></tr></thead><tbody><tr><td style="text-align:left;">no-referrer</td><td style="text-align:left;">✅</td><td style="text-align:left;">-</td><td style="text-align:left;">-</td></tr><tr><td style="text-align:left;">origin</td><td style="text-align:left;">-</td><td style="text-align:left;">✅</td><td style="text-align:left;">-</td></tr><tr><td style="text-align:left;">unsafe-url</td><td style="text-align:left;">-</td><td style="text-align:left;">-</td><td style="text-align:left;">✅</td></tr><tr><td style="text-align:left;">strict-origin</td><td style="text-align:left;">从 HTTPS 请求到 HTTP 的网址时</td><td style="text-align:left;">满足以下任意条件：&lt;br&gt;&lt;br&gt;&lt;ul&gt;&lt;li&gt;从 HTTPS 请求到 HTTPS 网址时&lt;/li&gt;&lt;li&gt;从 HTTP 请求到 HTTP 的网址时&lt;/li&gt;</td><td style="text-align:left;">-</td></tr><tr><td style="text-align:left;">no-referrer-when-downgrade</td><td style="text-align:left;">从 HTTPS 请求到 HTTP 的网址时</td><td style="text-align:left;">-</td><td style="text-align:left;">满足以下任意条件：&lt;br&gt;&lt;br&gt;&lt;ul&gt;&lt;li&gt;从 HTTPS 请求到 HTTPS 网址时&lt;/li&gt;&lt;li&gt;从 HTTP 请求到 HTTP 的网址时&lt;/li&gt;</td></tr><tr><td style="text-align:left;">origin-when-cross-origin</td><td style="text-align:left;">-</td><td style="text-align:left;">跨域请求</td><td style="text-align:left;">同源请求</td></tr><tr><td style="text-align:left;">same-origin</td><td style="text-align:left;">跨域请求</td><td style="text-align:left;">-</td><td style="text-align:left;">同源请求</td></tr><tr><td style="text-align:left;">strict-origin-when-cross-origin</td><td style="text-align:left;">从 HTTPS 请求到 HTTP 的网址时</td><td style="text-align:left;">满足以下任意条件：&lt;br&gt;&lt;br&gt;&lt;ul&gt;&lt;li&gt;跨域请求&lt;/li&gt;&lt;li&gt;从 HTTPS 请求到 HTTPS 网址时&lt;/li&gt;&lt;li&gt;从 HTTP 请求到 HTTP 网址时&lt;/li&gt;</td><td style="text-align:left;">同源请求</td></tr></tbody></table><h3 id="浏览器默认的策略" tabindex="-1"><a class="header-anchor" href="#浏览器默认的策略" aria-hidden="true">#</a> 浏览器默认的策略</h3>`,40),g=e("thead",null,[e("tr",null,[e("th",{style:{"text-align":"left"}},"浏览器"),e("th",{style:{"text-align":"left"}},"默认的策略")])],-1),u=e("td",{style:{"text-align":"left"}},"Chrome",-1),m={style:{"text-align":"left"}},b={href:"https://developer.chrome.com/blog/referrer-policy-new-chrome-default/",target:"_blank",rel:"noopener noreferrer"},_=e("td",{style:{"text-align":"left"}},"Firefox",-1),y={style:{"text-align":"left"}},v={href:"https://blog.mozilla.org/security/2021/03/22/firefox-87-trims-http-referrers-by-default-to-protect-user-privacy/",target:"_blank",rel:"noopener noreferrer"},x=e("td",{style:{"text-align":"left"}},"Edge",-1),T={style:{"text-align":"left"}},k={href:"https://docs.microsoft.com/zh-cn/deployedge/microsoft-edge-policies",target:"_blank",rel:"noopener noreferrer"},P=e("td",{style:{"text-align":"left"}},"Safari",-1),R={style:{"text-align":"left"}},w={href:"https://webkit.org/blog/9661/preventing-tracking-prevention-tracking/",target:"_blank",rel:"noopener noreferrer"},j=i(`<h3 id="设置-policy-的方法" tabindex="-1"><a class="header-anchor" href="#设置-policy-的方法" aria-hidden="true">#</a> 设置 Policy 的方法</h3><p>当我们需要变更 Referer 策略的时候，浏览器本身以及W3C规范都给我们提供了路径，有以下几种方式可以操作：</p><h4 id="rel-属性" tabindex="-1"><a class="header-anchor" href="#rel-属性" aria-hidden="true">#</a> rel 属性</h4><p>&amp;lt;a&gt;、&amp;lt;area&gt;标签均支持 rel 属性，最常见的就是在 &amp;lt;a&gt; 标签中对单个链接设置 <code>rel=&amp;quot;noreferrer&amp;quot;</code></p><div class="language-javaScript line-numbers-mode" data-ext="javaScript"><pre class="language-javaScript"><code>&amp;lt;a href=&amp;quot;xxx&amp;quot; rel=&amp;quot;noreferrer&amp;quot; target=&amp;quot;_blank&amp;quot;&amp;gt;新地址&amp;lt;/a&amp;gt;
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ecf32aea34a34a20bd3b464fce113ede~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p><p>设置之后，新开的网页请求头中，将不再携带来源页面的 Referer 信息。</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7d3159e114dd4a1b92b2f9e9fd8cc127~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p><h4 id="lt-meta-标签" tabindex="-1"><a class="header-anchor" href="#lt-meta-标签" aria-hidden="true">#</a> &amp;lt;meta&gt; 标签</h4><p>在HTML的 &amp;lt;head&gt; 标签内，可以新增 &amp;lt;meta&gt; 标签，设置整个网页的 Referer Policy 策略。</p><div class="language-javaScript line-numbers-mode" data-ext="javaScript"><pre class="language-javaScript"><code>&amp;lt;meta name=&amp;quot;referrer&amp;quot; content=&amp;quot;no-referrer&amp;quot;&amp;gt;
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h4 id="headers-请求头" tabindex="-1"><a class="header-anchor" href="#headers-请求头" aria-hidden="true">#</a> Headers 请求头</h4><p>更改 HTTP 头信息中的 Referer-Policy 值即可。比如你使用的是 Nginx，则可以设置 add_headers 设置请求头。</p><div class="language-javaScript line-numbers-mode" data-ext="javaScript"><pre class="language-javaScript"><code>add_header Referrer-Policy &amp;quot;no-referrer&amp;quot;;
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>设置完请求头，最终体现在浏览器 Headers 里字段是：</p><div class="language-javaScript line-numbers-mode" data-ext="javaScript"><pre class="language-javaScript"><code>Referrer-Policy: no-referrer
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h4 id="referrerpolicy-属性" tabindex="-1"><a class="header-anchor" href="#referrerpolicy-属性" aria-hidden="true">#</a> referrerpolicy 属性</h4><p>这个目前看还是实验性功能，并且在 IE 浏览器上也是完全不支持的。</p><div class="language-javaScript line-numbers-mode" data-ext="javaScript"><pre class="language-javaScript"><code>&amp;lt;a href=&amp;quot;xxx&amp;quot; referrerpolicy=&amp;quot;no-referrer&amp;quot; target=&amp;quot;_blank&amp;quot;&amp;gt;新地址&amp;lt;/a&amp;gt;
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>支持的标签：&amp;lt;a&gt;、&amp;lt;area&gt;、&amp;lt;img&gt;、&amp;lt;iframe&gt;、&amp;lt;link&gt;</p><h4 id="优先级" tabindex="-1"><a class="header-anchor" href="#优先级" aria-hidden="true">#</a> 优先级</h4><p>以上几种设置方式，有页面级和元素级，当这两者都存在时，优先级按以下方式进行生效：</p><p>1、元素级政策</p><p>2、页面级政策</p><p>3、浏览器默认</p><p>举例：</p><div class="language-javaScript line-numbers-mode" data-ext="javaScript"><pre class="language-javaScript"><code>&amp;lt;meta name=&amp;quot;referrer&amp;quot; content=&amp;quot;strict-origin-when-cross-origin&amp;quot;&amp;gt;

&amp;lt;a href=&amp;quot;https://foo.com&amp;quot; rel=&amp;quot;no-referrer&amp;quot; target=&amp;quot;_blank&amp;quot;&amp;gt;地址一&amp;lt;/a&amp;gt;
&amp;lt;a href=&amp;quot;https://bar.com&amp;quot; target=&amp;quot;_blank&amp;quot;&amp;gt;地址二&amp;lt;/a&amp;gt;
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>页面中地址一，则优先按元素级策略，走 no-referrer，而页面中其他元素（包括但不限于 a 标签）则按 meta 页面级策略执行</p><h1 id="作用及使用场景" tabindex="-1"><a class="header-anchor" href="#作用及使用场景" aria-hidden="true">#</a> 作用及使用场景</h1><p>以下列举了几个比较常见的作用及使用场景：</p><h3 id="_1-防盗链" tabindex="-1"><a class="header-anchor" href="#_1-防盗链" aria-hidden="true">#</a> （1）防盗链</h3><p>以 CDN 加速为例，一般都提供了防盗链配置，其内部实现原理是按照 Referer 来源来判断是否在配置的白名单或者黑名单中，来决定资源能否可被访问。</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/68641f37f1ef41918d2c780851924e75~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p>`,33),H={href:"https://help.aliyun.com/document_detail/27134.html",target:"_blank",rel:"noopener noreferrer"},q=i('<h3 id="_2-埋点分析" tabindex="-1"><a class="header-anchor" href="#_2-埋点分析" aria-hidden="true">#</a> （2）埋点分析</h3><p>埋点分析有一种情况是用于追溯用户的完整访问路径，这个时候可以依赖的就是 HTTP Referer，可以通过 Referer 来源逐步分析用户的来源网址和整体访问链路。</p><h3 id="_3-错误排查-接口日志" tabindex="-1"><a class="header-anchor" href="#_3-错误排查-接口日志" aria-hidden="true">#</a> （3）错误排查（接口日志）</h3><p>排查接口请求报错时，一般会关注日志系统，而日志系统里如果没有对于接口访问来源的字段，那么想快速精确找到接口访问的页面是比较困难的。这时候 Referer 就提供了一个比较好的帮助，可以看到接口的请求来源。</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/94c75c68d4184927bf5370adcb2cb4cd~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p><h3 id="_4-用户隐私保护" tabindex="-1"><a class="header-anchor" href="#_4-用户隐私保护" aria-hidden="true">#</a> （4）用户隐私保护</h3><p>为什么各浏览器厂商都升级了 Policy 默认策略？</p><p>目的其实是为了保护用户隐私，过于完整的 Referer 信息能够通过日志抓取到完整链路，也就意味着你的访问路径和来源是没有任何隐藏，这样可能会对隐私及网站的安全性带来一定的危害。</p><h1 id="参考资料" tabindex="-1"><a class="header-anchor" href="#参考资料" aria-hidden="true">#</a> 参考资料</h1>',9),S={href:"https://zh.wikipedia.org/wiki/HTTP%E5%8F%83%E7%85%A7%E4%BD%8D%E5%9D%80",target:"_blank",rel:"noopener noreferrer"},z={href:"https://www.ruanyifeng.com/blog/2019/06/http-referer.html",target:"_blank",rel:"noopener noreferrer"},N={href:"https://developer.mozilla.org/zh-CN/docs/Web/HTML/Link_types",target:"_blank",rel:"noopener noreferrer"},E={href:"https://web.dev/referrer-best-practices/",target:"_blank",rel:"noopener noreferrer"},C=e("h2",{id:"推荐阅读",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#推荐阅读","aria-hidden":"true"},"#"),r(" 推荐阅读")],-1),L={href:"https://juejin.cn/post/7127440050937151525",target:"_blank",rel:"noopener noreferrer"},D={href:"https://juejin.cn/post/7124839474575441934",target:"_blank",rel:"noopener noreferrer"},B={href:"https://juejin.cn/post/7122240814108901406",target:"_blank",rel:"noopener noreferrer"},F={href:"https://juejin.cn/post/7119639489567260686",target:"_blank",rel:"noopener noreferrer"},I={href:"https://juejin.cn/post/7117042614313943070",target:"_blank",rel:"noopener noreferrer"},M=e("h2",{id:"开源作品",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#开源作品","aria-hidden":"true"},"#"),r(" 开源作品")],-1),U=e("ul",null,[e("li",null,"政采云前端小报")],-1),V={href:"https://www.zoo.team/openweekly/",target:"_blank",rel:"noopener noreferrer"},O=e("ul",null,[e("li",null,"商品选择 sku 插件")],-1),W={href:"https://github.com/zcy-inc/skuPathFinder-back",target:"_blank",rel:"noopener noreferrer"},A=e("h2",{id:"招贤纳士",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#招贤纳士","aria-hidden":"true"},"#"),r(" 招贤纳士")],-1),G=e("p",null,"政采云前端团队（ZooTeam），一个年轻富有激情和创造力的前端团队，隶属于政采云产品研发部，Base 在风景如画的杭州。团队现有 90 余个前端小伙伴，平均年龄 27 岁，近 4 成是全栈工程师，妥妥的青年风暴团。成员构成既有来自于阿里、网易的“老”兵，也有浙大、中科大、杭电等校的应届新人。团队在日常的业务对接之外，还在物料体系、工程平台、搭建平台、性能体验、云端应用、数据分析及可视化等方向进行技术探索和实战，推动并落地了一系列的内部技术产品，持续探索前端技术体系的新边界。",-1),Z=e("p",null,[r("如果你想改变一直被事折腾，希望开始能折腾事；如果你想改变一直被告诫需要多些想法，却无从破局；如果你想改变你有能力去做成那个结果，却不需要你；如果你想改变你想做成的事需要一个团队去支撑，但没你带人的位置；如果你想改变既定的节奏，将会是“5 年工作时间 3 年工作经验”；如果你想改变本来悟性不错，但总是有那一层窗户纸的模糊… 如果你相信相信的力量，相信平凡人能成就非凡事，相信能遇到更好的自己。如果你希望参与到随着业务腾飞的过程，亲手推动一个有着深入的业务理解、完善的技术体系、技术创造价值、影响力外溢的前端团队的成长历程，我觉得我们该聊聊。任何时间，等着你写点什么，发给 "),e("code",null,"ZooTeam@cai-inc.com")],-1),J=e("p",null,[e("img",{src:"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/98d3aa3d1f8646a8bcda8cfd9e335a4b~tplv-k3u1fbpfcp-zoom-1.image",alt:""})],-1);function Q(Y,K){const t=d("ExternalLinkIcon");return l(),o("div",null,[c,p,e("p",null,[r("> 这是第 155 篇不掺水的原创，想获取更多原创好文，请搜索公众号关注我们吧~ 本文首发于政采云前端博客："),e("a",h,[r("学习 HTTP Referer"),a(t)])]),f,e("table",null,[g,e("tbody",null,[e("tr",null,[u,e("td",m,[r("Chrome 85 版本默认策略变更为：strict-origin-when-cross-origin<br>原策略：no-referrer-when-downgrade<br><br>详细可查看："),e("a",b,[r("https://developer.chrome.com/blog/referrer-policy-new-chrome-default/"),a(t)])])]),e("tr",null,[_,e("td",y,[r("Firefox 87 版本默认策略变更为：strict-origin-when-cross-origin<br>原策略：strict-origin-when-cross-origin<br><br>详细可查看："),e("a",v,[r("https://blog.mozilla.org/security/2021/03/22/firefox-87-trims-http-referrers-by-default-to-protect-user-privacy/"),a(t)])])]),e("tr",null,[x,e("td",T,[r("Edge 88 版本默认策略变更为：strict-origin-when-cross-origin<br>原策略：no-referrer-when-downgrade<br><br>详细可查看："),e("a",k,[r("https://docs.microsoft.com/zh-cn/deployedge/microsoft-edge-policies"),a(t)])])]),e("tr",null,[P,e("td",R,[r("类似于 strict-origin-when-cross-origin<br><br>依赖智能跟踪预防 (ITP)策略，详细可查看："),e("a",w,[r("https://webkit.org/blog/9661/preventing-tracking-prevention-tracking/"),a(t)])])])])]),j,e("p",null,[r("图片来自"),e("a",H,[r("阿里云CDN的防盗链配置"),a(t)])]),q,e("ul",null,[e("li",null,[e("a",S,[r("HTTP来源地址"),a(t)])]),e("li",null,[e("a",z,[r("HTTP Referer 教程"),a(t)])]),e("li",null,[e("a",N,[r("链接类型"),a(t)])]),e("li",null,[e("a",E,[r("引荐来源 (Referer) 和引荐来源政策 (Referrer-Policy) 最佳实践"),a(t)])])]),C,e("p",null,[e("a",L,[r("浅谈低代码平台远程组件加载方案"),a(t)])]),e("p",null,[e("a",D,[r("前端富文本基础及实现"),a(t)])]),e("p",null,[e("a",B,[r("可视化搭建系统之数据源"),a(t)])]),e("p",null,[e("a",F,[r("表单数据形式配置化设计"),a(t)])]),e("p",null,[e("a",I,[r("如何将传统 Web 框架部署到 Serverless"),a(t)])]),M,U,e("p",null,[e("strong",null,[r("开源地址 "),e("a",V,[r("www.zoo.team/openweekly/"),a(t)])]),r(" (小报官网首页有微信交流群)")]),O,e("p",null,[e("strong",null,[r("开源地址 "),e("a",W,[r("https://github.com/zcy-inc/skuPathFinder-back/"),a(t)])])]),A,G,Z,J])}const $=n(s,[["render",Q],["__file","学习 HTTP Referer.html.vue"]]);export{$ as default};
